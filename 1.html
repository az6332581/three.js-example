<!DOCTYPE html>
<html>

<head>
    <style>
        body {
            margin: 0;
        }

        canvas {
            display: block;
        }
    </style>
</head>

<body>
    <div id="app">
        <div id="controls">
            <input type="file" @change="handleFileChange" accept=".stl">
            顏色：
            <input type="color" id="colorPicker" @input="updateColor" value="#a8a8a8" />
        </div>
    </div>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/STLLoader.js"></script>
    <script>
        const { createApp, ref, watch } = Vue

        createApp({
            setup() {
                let L1 = ref(0)
                let currentMesh = null;
                let currentMaterial = null;

                /* 建場景  */
                const scene = new THREE.Scene();

                /* 建相機 */
                const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

                /* 渲染 */
                const renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                renderer.setClearColor(0x000000);

                /* 建滑鼠 */
                const controls = new THREE.OrbitControls(camera, renderer.domElement);

                /* 建環境光 */
                const ambientLight = new THREE.AmbientLight(0x404040);
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
                scene.add(directionalLight);

                /* 上下左右前後添加光源 (可選) */
                const pointLight1 = new THREE.PointLight(0xffffff, 1, 200);
                pointLight1.position.set(0, 0, 100);
                scene.add(pointLight1);
                const pointLight2 = new THREE.PointLight(0xffffff, 1, 200);
                pointLight2.position.set(0, 0, -100);
                scene.add(pointLight2);
                const pointLight3 = new THREE.PointLight(0xffffff, 1, 200);
                pointLight3.position.set(0, 100, 0);
                scene.add(pointLight3);
                const pointLight4 = new THREE.PointLight(0xffffff, 1, 200);
                pointLight4.position.set(0, -100, 0);
                scene.add(pointLight4);
                const pointLight5 = new THREE.PointLight(0xffffff, 1, 200);
                pointLight5.position.set(100, 0, 0);
                scene.add(pointLight5);
                const pointLight6 = new THREE.PointLight(0xffffff, 1, 200);
                pointLight6.position.set(-100, 0, 0);
                scene.add(pointLight6);

                /* 渲染 */
                animate = () => {
                    requestAnimationFrame(animate);
                    renderer.render(scene, camera);
                    controls.update();
                }
                animate();


                const handleFileChange = (event) => {
                    const file = event.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = function (e) {
                            if (currentMesh) {
                                scene.remove(currentMesh);
                                currentMesh.geometry.dispose();
                                currentMesh.material.dispose();
                                currentMesh = null;
                            }

                            const arrayBuffer = e.target.result;
                            const loader = new THREE.STLLoader();
                            const geometry = loader.parse(arrayBuffer);

                            const colorPicker = document.getElementById("colorPicker");
                            currentMaterial = new THREE.MeshStandardMaterial({ color: colorPicker.value });

                            const mesh = new THREE.Mesh(geometry, currentMaterial);
                            mesh.position.y = 1;
                            scene.add(mesh);

                            currentMesh = mesh;

                            /* 攝影機位置 */
                            const boundingBox = new THREE.Box3().setFromObject(mesh);
                            const center = boundingBox.getCenter(new THREE.Vector3());
                            controls.target.copy(center);
                            camera.lookAt(center);
                            const boundingSphere = new THREE.Sphere();
                            boundingBox.getBoundingSphere(boundingSphere);
                            const radius = boundingSphere.radius;
                            const offset = radius * 1.2;
                            camera.position.set(center.x + offset, center.y + offset, center.z + offset);
                        };
                        reader.readAsArrayBuffer(file);
                    }
                };

                const updateColor = (event) => {
                    const color = event.target.value;
                    if (currentMaterial) {
                        currentMaterial.color.set(color);
                    }
                };

                return {
                    L1,
                    handleFileChange
                }
            }
        }).mount('#app')

    </script>
</body>

</html>